/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.15 public/models/Avatar.glb -o src/components/Avatar.jsx -r public 
*/

import React, { useRef } from "react";
// import { useGLTF } from "@react-three/drei";
import { useLoader } from "@react-three/fiber";
import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader";
import { useAnimations, useFBX } from "@react-three/drei";
import { useState } from "react";
import { useEffect } from "react";
import { useControls } from "leva";
import { useMemo } from "react";
import { useFrame } from "@react-three/fiber";
import { useGLTF } from "@react-three/drei";
import { Expression } from "./FacialAnimation";
import * as THREE from "three";
import {
  expression_que,
  avatar_smile,
  avatar_blink,
  avatar_speak,
  updateMouthqueDefault,
} from "../helpers/expression-helpers";
import axios from "axios";
import { SpeechApiService } from "../services/speechApiService";
import { createAudioFromBase64 } from "../helpers/base64toaudio-helper";
import { useDispatch, useSelector } from "react-redux";
import { INITIALISE as InitAudioData } from "../store/actions/audioData";
import { INITIALISE as InitAudioStatus } from "../store/actions/audioStatus";

export function Avatar(props) {
  const [audio_bytes, setaudio_bytes] = useState();
  const dispatch = useDispatch();
  const { audio_byte, mouthque } = useSelector((state) => state.audioData);
  // const { nodes, materials, scene } = useGLTF("/models/Avatar.glb");
  const { playAudio, script, morphTargetSmoothing, smoothMorphTarget } =
    useControls({
      playAudio: true,
      smoothMorphTarget: true,
      morphTargetSmoothing: 0.1,
      script: {
        value: "hello",
        options: ["hello"],
      },
    });

  const headFollow = true;


const facialExpressions = {
  default: {},
  smile_1: {
    browInnerUp: 0.17,
    eyeSquintLeft: 0.4,
    eyeSquintRight: 0.44,
    noseSneerLeft: 0.1700000727403593,
    noseSneerRight: 0.14000002836874015,
    mouthPressLeft: 0.61,
    mouthPressRight: 0.41000000000000003,
    mouthSmileRight: 0.6,
    mouthSmileLeft: 0.6

  },
  smile_2: {
    browInnerUp: 0.25,
    eyeSquintLeft: 0.5,
    eyeSquintRight: 0.5,
    noseSneerLeft: 0.3,
    noseSneerRight: 0.3,
    mouthPressLeft: 0.5,
    mouthPressRight: 0.5,
    mouthSmileRight: 0.8,
    mouthSmileLeft: 0.8

  },
  smile_3: {
    browInnerUp: 0.17,
    eyeSquintLeft: 0.4,
    eyeSquintRight: 0.44,
    noseSneerLeft: 0.1700000727403593,
    noseSneerRight: 0.14000002836874015,
    mouthPressLeft: 0.61,
    mouthPressRight: 0.41000000000000003,
    mouthSmileRight: 0.6,
    mouthSmileLeft: 0.6

  },


  smile_4: {
    browInnerUp: 0.25,
    eyeSquintLeft: 0.5,
    eyeSquintRight: 0.5,
    noseSneerLeft: 0.3,
    noseSneerRight: 0.3,
    mouthPressLeft: 0.5,
    mouthPressRight: 0.5,
    mouthSmileRight: 0.8,
    mouthSmileLeft: 0.8
  },


  smile_5: {
    browInnerUp: 0.17,
    eyeSquintLeft: 0.4,
    eyeSquintRight: 0.44,
    noseSneerLeft: 0.1700000727403593,
    noseSneerRight: 0.14000002836874015,
    mouthPressLeft: 0.61,
    mouthPressRight: 0.41000000000000003,
    mouthSmileRight: 0.6,
    mouthSmileLeft: 0.6

  },
}


  // const audio = useMemo(() => new Audio(`/audios/${script}.mp3`), [script]);
  const audio = useMemo(() => {
    if (!audio_bytes) return null;
    return createAudioFromBase64(audio_bytes);
  }, [audio_bytes]);

  useEffect(() => {
    const audioControl = () => {
      if (playAudio) {
        console.log("Play AUDIO");
        audio.play();
      } else {
        audio.pause();
      }
    };
    if (audio_bytes) {
      console.log("CHECK CONDITION");
      audioControl();
    }
  }, [playAudio, audio_bytes]);

  let { nodes, materials, scene } = useLoader(
    GLTFLoader,
    "models/Avatar_3.glb"
  );

  useEffect(() => {
    if (audio_byte && mouthque) {
      console.log("RECVIDED AUDIO DATA", mouthque);
      setaudio_bytes(audio_byte);
      updateMouthqueDefault(mouthque);
    }
  }, [audio_byte, mouthque]);

  materials.skinning = true;
  // const { nodes, materials, scene } = useGLTF('/model.gltf');

  const { animations: idle_1 } = useFBX("/animations/animation_1.fbx");
  const { animations: idle_2 } = useFBX("/animations/animation_2.fbx");
  const { animations: idle_3 } = useFBX("/animations/animation_3.fbx");
  const { animations: idle_4 } = useFBX("/animations/animation_4.fbx");
  const { animations: idle_5 } = useFBX("/animations/animation_5.fbx");
  const { animations: idle_6 } = useFBX("/animations/animation_6.fbx");

  // console.log(idle_1)

  idle_1[0].name = "idle_1";
  idle_2[0].name = "idle_2";
  idle_3[0].name = "idle_3";
  idle_4[0].name = "idle_4";
  idle_5[0].name = "idle_5";
  idle_6[0].name = "idle_6";

  const [animation, setAnimation] = useState("idle_4");

  const group = useRef();
  const { actions } = useAnimations(
    [idle_1[0], idle_2[0], idle_3[0], idle_4[0], idle_4[0], idle_6[0]],
    group
  );

  const dialogue =
    "Hello, I am a virtual Avatar a bot designed by Integra Private Limited";

  // useEffect(() => {
  //   const speechData = async () => {
  //     try {
  //       const { metadata, mouthCues } = await SpeechApiService.getSpeechData(
  //         dialogue
  //       );
  //       setaudio_bytes(metadata.soundFile);
  //       updateMouthqueDefault(mouthCues);
  //     } catch (error) {
  //       console.log(error);
  //     }
  //   };
  //   speechData();
  // }, []);

  useEffect(() => {
    actions[animation].reset().fadeIn(0.5).play();
    return () => actions[animation].fadeOut(0.5);
  }, [animation]);

  useFrame((state) => {
    if (headFollow) {
      group.current.getObjectByName("Head").lookAt(state.camera.position);
    }
  });

  useFrame((state) => {
    const smile_nodes = avatar_smile(nodes, morphTargetSmoothing);
    nodes = smile_nodes;
  });

  let j = 0;

  useFrame((state) => {
    const blink_nodes = avatar_blink(nodes, morphTargetSmoothing);
    nodes = blink_nodes;
  });

  useFrame(() => {
    if (audio_bytes) {
      if (audio.paused || audio.ended) {
        console.log("IDLE");
        setAnimation("idle_4");
        return;
      }
      console.log("SPEAKING");
      const audio_nodes = avatar_speak(
        nodes,
        morphTargetSmoothing,
        audio,
        "default"
      );
      nodes = audio_nodes;
    }
  });

  const upperTeethMaterial = useMemo(() => {
    const material = new THREE.MeshStandardMaterial({
      // color: 0xFFFFFF, // Adjust the initial color as needed
      roughness: 0, // Adjust roughness
      metalness: 0.0, // Adjust metalness
      map: materials.AvatarTeethUpper.map, // Replace '/path/to/teeth_texture.jpg' with the actual path to your image
      // Add other material properties here if needed
    });

    material.color.multiplyScalar(3); // You can adjust the factor as needed

    // Enable shadows for the material
    material.shadowSide = THREE.FrontSide;
    material.receiveShadow = true;

    return material;
  }, [materials]); //

  const [blink, setBlink] = useState(true);
  const [smile, setSmile] = useState(0.6)
  const [facialExpression, setFacialExpression] = useState("");

  const lerpMorphTarget = (target, value, speed = 0.001) => {
    scene.traverse((child) => {
      if (child.isSkinnedMesh && child.morphTargetDictionary) {
        const index = child.morphTargetDictionary[target];
        if (
          index === undefined ||
          child.morphTargetInfluences[index] === undefined
        ) {
          return;
        }
        child.morphTargetInfluences[index] = THREE.MathUtils.lerp(
          child.morphTargetInfluences[index],
          value,
          speed
        );

        if (!setupMode) {
          try {
            set({
              [target]: value,
            });
          } catch (e) {}
        }
      }
    });
  };

  const setupMode = false
  const winkLeft = false
  const winkRight = false

  
  useFrame(() => {
    !setupMode &&
      Object.keys(nodes.AvatarHead.morphTargetDictionary).forEach((key) => {
        const mapping = facialExpressions[facialExpression];
        if (key === "mouthSmileLeft" || key === "mouthSmileRight") {
          return; // eyes wink/blink are handled separately
        }
        if (mapping && mapping[key]) {
          lerpMorphTarget(key, mapping[key], 0.1);
        } else {
          lerpMorphTarget(key, 0, 0.1);
        }
      });

    lerpMorphTarget("mouthSmileLeft", smile > 0.4 || winkLeft ? 1 : 0, smile);
    lerpMorphTarget("mouthSmileRight", smile > 0.4 || winkRight ? 1 : 0, smile);
    // lerpMorphTarget("mouthSmileLeft", blink || winkLeft ? 1 : 0, 0.5);
    // lerpMorphTarget("mouthSmileRight", blink || winkRight ? 1 : 0, 0.5);

    // LIPSYNC
    if (setupMode) {
      return;
    }
  })

  useFrame(() => {
    !setupMode &&
      Object.keys(nodes.AvatarHead.morphTargetDictionary).forEach((key) => {
        const mapping = facialExpressions[facialExpression];
        if (key === "eyeBlinkLeft" || key === "eyeBlinkRight" || key === "eyeSquintLeft" || key === "eyeSquintRight") {
          return; // eyes wink/blink are handled separately
        }
        if (mapping && mapping[key]) {
          lerpMorphTarget(key, mapping[key], 0.5);
        } else {
          lerpMorphTarget(key, 0, 0.5);
        }
      });

    lerpMorphTarget("eyeBlinkLeft", blink || winkLeft ? 1 : 0, 0.5);
    lerpMorphTarget("eyeBlinkRight", blink || winkRight ? 1 : 0, 0.5);
    // lerpMorphTarget("eyeSquintLeft", blink || winkLeft ? 1 : 0, 0.5);
    // lerpMorphTarget("eyeSquintRight", blink || winkRight ? 1 : 0, 0.5);

    // LIPSYNC
    if (setupMode) {
      return;
    }

    // const appliedMorphTargets = [];
    // if (message && lipsync) {
    //   const currentAudioTime = audio.currentTime;
    //   for (let i = 0; i < lipsync.mouthCues.length; i++) {
    //     const mouthCue = lipsync.mouthCues[i];
    //     if (
    //       currentAudioTime >= mouthCue.start &&
    //       currentAudioTime <= mouthCue.end
    //     ) {
    //       appliedMorphTargets.push(corresponding[mouthCue.value]);
    //       lerpMorphTarget(corresponding[mouthCue.value], 1, 0.2);
    //       break;
    //     }
    //   }
    // }

    // Object.values(corresponding).forEach((value) => {
    //   if (appliedMorphTargets.includes(value)) {
    //     return;
    //   }
    //   lerpMorphTarget(value, 0, 0.1);
    // });
  });

  useEffect(() => {
    let blinkTimeout;
    const nextBlink = () => {
      blinkTimeout = setTimeout(() => {
        setBlink(true);
        setTimeout(() => {
          setBlink(false);
          nextBlink();
        }, 100);
      }, THREE.MathUtils.randInt(2000, 10000));
    };
    nextBlink();
    return () => clearTimeout(blinkTimeout);
  }, []);

  useEffect(() => {
    let smileTimeout;
    const nextSmile = () => {
      smileTimeout = setTimeout(() => {
        setSmile(THREE.MathUtils.randFloat(0.6, 1));
        setTimeout(() => {
          setSmile(THREE.MathUtils.randFloat(0.4, 0.6));
          nextSmile();
        }, 1000);
      }, THREE.MathUtils.randInt(2000, 6000));
    };
    nextSmile();
    return () => clearTimeout(smileTimeout);
  }, []);



  return (
    <group {...props} dispose={null} ref={group}>
      <primitive object={scene} />
      <group rotation={[Math.PI / 2, 0, 0]}>
        <skinnedMesh
          geometry={nodes.AvatarBody.geometry}
          material={materials.AvatarBody}
          skeleton={nodes.AvatarBody.skeleton}
        />
        <skinnedMesh
          name="AvatarEyelashes"
          geometry={nodes.AvatarEyelashes.geometry}
          material={materials.AvatarEyelashes}
          skeleton={nodes.AvatarEyelashes.skeleton}
          morphTargetDictionary={nodes.AvatarEyelashes.morphTargetDictionary}
          morphTargetInfluences={nodes.AvatarEyelashes.morphTargetInfluences}
        />
        <skinnedMesh
          name="AvatarHead"
          geometry={nodes.AvatarHead.geometry}
          material={materials.AvatarHead}
          skeleton={nodes.AvatarHead.skeleton}
          morphTargetDictionary={nodes.AvatarHead.morphTargetDictionary}
          morphTargetInfluences={nodes.AvatarHead.morphTargetInfluences}
        />
        <skinnedMesh
          geometry={nodes.AvatarLeftCornea.geometry}
          material={materials.AvatarLeftCornea}
          skeleton={nodes.AvatarLeftCornea.skeleton}
        />
        <skinnedMesh
          geometry={nodes.AvatarLeftEyeball.geometry}
          material={materials.AvatarLeftEyeball}
          skeleton={nodes.AvatarLeftEyeball.skeleton}
        />
        <skinnedMesh
          geometry={nodes.AvatarRightCornea.geometry}
          material={materials.AvatarRightCornea}
          skeleton={nodes.AvatarRightCornea.skeleton}
        />
        <skinnedMesh
          geometry={nodes.AvatarRightEyeball.geometry}
          material={materials.AvatarRightEyeball}
          skeleton={nodes.AvatarRightEyeball.skeleton}
        />
        <skinnedMesh
          name="AvatarTeethLower"
          geometry={nodes.AvatarTeethLower.geometry}
          material={materials.AvatarTeethLower}
          skeleton={nodes.AvatarTeethLower.skeleton}
          morphTargetDictionary={nodes.AvatarTeethLower.morphTargetDictionary}
          morphTargetInfluences={nodes.AvatarTeethLower.morphTargetInfluences}
        />
        <skinnedMesh
          geometry={nodes.AvatarTeethUpper.geometry}
          skeleton={nodes.AvatarTeethUpper.skeleton}
          material={upperTeethMaterial}
          castShadow
        />
        <skinnedMesh
          geometry={nodes.haircut.geometry}
          material={materials.haircut}
          skeleton={nodes.haircut.skeleton}
        />
        <skinnedMesh
          geometry={nodes.outfit_bottom.geometry}
          material={materials.outfit_bottom}
          skeleton={nodes.outfit_bottom.skeleton}
        />
        <skinnedMesh
          geometry={nodes.outfit_shoes.geometry}
          material={materials.outfit_shoes}
          skeleton={nodes.outfit_shoes.skeleton}
        />
        <skinnedMesh
          geometry={nodes.outfit_top.geometry}
          material={materials.outfit_top}
          skeleton={nodes.outfit_top.skeleton}
        />
      </group>
    </group>
  );
}

// useGLTF.preload("/models/Avatar_2.glb");